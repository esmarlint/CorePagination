using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Common
{
    /// <summary>
    /// Specifies the order of pagination.
    /// </summary>
    public enum PaginationOrder
    {
        /// <summary>
        /// Indicates ascending order.
        /// </summary>
        Ascending,
        /// <summary>
        /// Indicates descending order.
        /// </summary>
        Descending
    }
}

﻿namespace CorePagination.Contracts
{
    public interface IPagination<T, TParameters, TResult>
    {
        /// <summary>
        /// Paginates the provided IQueryable based on the given pagination parameters.
        /// </summary>
        /// <param name="query">The IQueryable to be paginated.</param>
        /// <param name="parameters">The parameters for pagination.</param>
        /// <returns>The pagination result.</returns>
        TResult Paginate(IQueryable<T> query, TParameters parameters);
    }
}

﻿using CorePagination.Paginators.Common;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Contracts
{
    /// <summary>
    /// Defines the contract for pagination operations.
    /// </summary>
    /// <typeparam name="T">The type of the elements to be paginated.</typeparam>
    /// <typeparam name="TParameters">The type of the pagination parameters.</typeparam>
    /// <typeparam name="TResult">The type of the pagination result.</typeparam>
    public interface IPaginationAsync<T, TParameters, TResult>
        where TParameters : PagePaginatorParameters
        where TResult : class
    {
        /// <summary>
        /// Paginates the provided IQueryable based on the given pagination parameters.
        /// </summary>
        /// <param name="query">The IQueryable to be paginated.</param>
        /// <param name="parameters">The parameters for pagination.</param>
        /// <returns>The pagination result.</returns>
        TResult Paginate(IQueryable<T> query, TParameters parameters);

        /// <summary>
        /// Paginates the provided IQueryable based on the given pagination parameters.
        /// </summary>
        /// <param name="query">The IQueryable to be paginated.</param>
        /// <param name="parameters">The parameters for pagination.</param>
        /// <returns>A task that represents the asynchronous pagination operation. The task result contains the pagination result.</returns>
        Task<TResult> PaginateAsync(IQueryable<T> query, TParameters parameters);
    }
}

﻿using CorePagination.Paginators.Common;

namespace CorePagination.Contracts
{
    /// <summary>
    /// Represents the result of a pagination operation.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the pagination result.</typeparam>
    public interface IPaginationResult<T>
    {
        /// <summary>
        /// Gets or sets the paginated items.
        /// </summary>
        IEnumerable<T> Items { get; set; }
        /// <summary>
        /// Gets or sets the number of items per page.
        /// </summary>
        int PageSize { get; set; }
        /// <summary>
        /// Gets or sets the current page number.
        /// </summary>
        int Page { get; set; }
        /// <summary>
        /// Gets or sets the total number of items. This value may be null if the total count is not available.
        /// </summary>
        int? TotalItems { get; set; }
    }
}

﻿using CorePagination.Common;
using CorePagination.Paginators.Common;
using CorePagination.Paginators.CursorPaginator;
using CorePagination.Paginators.SimplePaginator;
using CorePagination.Paginators.SizeAwarePaginator;
using CorePagination.Support;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Extensions
{
    public static class PaginatorExtensions
    {
        /// <summary>
        /// Paginates a queryable source based on the specified page number and page size.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the source.</typeparam>
        /// <param name="query">The queryable source to paginate.</param>
        /// <param name="pageNumber">The one-based page number.</param>
        /// <param name="pageSize">The size of the page.</param>
        /// <returns>A <see cref="PaginationResult{T}"/> containing the paginated result.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the query is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if pageNumber or pageSize is less than one.</exception>
        public static PaginationResult<T> SimplePaginate<T>(this IQueryable<T> query, int pageNumber, int pageSize)
        {
            Guard.NotNull(query, nameof(query));

            var items = query.Skip((pageNumber - 1) * pageSize).Take(pageSize).ToList();
            return new PaginationResult<T>
            {
                Items = items,
                PageSize = pageSize,
                Page = pageNumber,
                TotalItems = null
            };
        }

        /// <summary>
        /// Paginates a queryable source based on the provided pagination parameters, including total item and page counts.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the source.</typeparam>
        /// <param name="query">The queryable source to paginate.</param>
        /// <param name="pageNumber">The one-based page number.</param>
        /// <param name="pageSize">The size of the page.</param>
        /// <returns>A <see cref="SizeAwarePaginationResult{T}"/> containing the paginated result with total counts.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the query is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if pageNumber or pageSize is less than one.</exception>
        public static SizeAwarePaginationResult<T> Paginate<T>(this IQueryable<T> query, int pageNumber, int pageSize)
        {
            Guard.NotNull(query, nameof(query));

            var totalItems = query.Count();
            var totalPages = (int)Math.Ceiling(totalItems / (double)pageSize);
            var items = query.Skip((pageNumber - 1) * pageSize).Take(pageSize).ToList();

            return new SizeAwarePaginationResult<T>
            {
                Items = items,
                PageSize = pageSize,
                Page = pageNumber,
                TotalItems = totalItems,
                TotalPages = totalPages
            };
        }

        /// <summary>
        /// Paginates a queryable source based on cursor parameters, suitable for efficient, stateless pagination.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the source.</typeparam>
        /// <typeparam name="TKey">The type used for the cursor property.</typeparam>
        /// <param name="query">The queryable source to paginate.</param>
        /// <param name="keySelector">The expression used to select the cursor property.</param>
        /// <param name="pageSize">The number of items per page.</param>
        /// <param name="currentCursor">The current cursor value. Default is the default value of <typeparamref name="TKey"/>.</param>
        /// <param name="order">The pagination order. Default is <see cref="PaginationOrder.Ascending"/>.</param>
        /// <returns>A <see cref="CursorPaginationResult{T, TKey}"/> containing the paginated result with cursor information.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the query or keySelector is null.</exception>
        public static CursorPaginationResult<T, TKey> CursorPaginate<T, TKey>(
            this IQueryable<T> query, Expression<Func<T, TKey>> keySelector, int pageSize, TKey currentCursor = default, PaginationOrder order = PaginationOrder.Ascending)
            where T : class
            where TKey : IComparable
        {
            Guard.NotNull(query, nameof(query));
            Guard.NotNull(keySelector, nameof(keySelector));

            var paginator = new CursorPaginator<T, TKey>(keySelector);
            var parameters = new CursorPaginationParameters<TKey> { PageSize = pageSize, CurrentCursor = currentCursor, Order = order };
            return paginator.Paginate(query, parameters);
        }

        /// <summary>
        /// Asynchronously paginates a queryable source based on the specified page number and page size.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the source.</typeparam>
        /// <param name="query">The queryable source to paginate.</param>
        /// <param name="pageNumber">The one-based page index.</param>
        /// <param name="pageSize">The size of the page.</param>
        /// <returns>A task that represents the asynchronous operation. The task result contains the <see cref="PaginationResult{T}"/>.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the query is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if pageNumber or pageSize are less than one.</exception>
        public static async Task<PaginationResult<T>> SimplePaginateAsync<T>(
            this IQueryable<T> query, int pageNumber, int pageSize)
        {
            Guard.NotNull(query, nameof(query));

            var items = await query.Skip((pageNumber - 1) * pageSize).Take(pageSize).ToListAsync();
            return new PaginationResult<T>
            {
                Items = items,
                PageSize = pageSize,
                Page = pageNumber,
                TotalItems = null
            };
        }

        /// <summary>
        /// Asynchronously paginates a queryable source based on the provided pagination parameters, including total item and page counts.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the source.</typeparam>
        /// <param name="query">The queryable source to paginate.</param>
        /// <param name="pageNumber">The one-based page index.</param>
        /// <param name="pageSize">The size of the page.</param>
        /// <returns>A task that represents the asynchronous operation. The task result contains the <see cref="SizeAwarePaginationResult{T}"/>.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the query is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if pageNumber or pageSize are less than one.</exception>
        public static async Task<SizeAwarePaginationResult<T>> PaginateAsync<T>(
            this IQueryable<T> query, int pageNumber, int pageSize)
        {
            Guard.NotNull(query, nameof(query));

            var items = await query.Skip((pageNumber - 1) * pageSize).Take(pageSize).ToListAsync();
            var totalItems = await query.CountAsync();
            var totalPages = (int)Math.Ceiling(totalItems / (double)pageSize);

            return new SizeAwarePaginationResult<T>
            {
                Items = items,
                PageSize = pageSize,
                Page = pageNumber,
                TotalItems = totalItems,
                TotalPages = totalPages
            };
        }

        /// <summary>
        /// Asynchronously paginates a queryable source based on cursor parameters, suitable for implementing efficient, stateful pagination.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the source.</typeparam>
        /// <typeparam name="TKey">The type used for the cursor property.</typeparam>
        /// <param name="query">The queryable source to paginate.</param>
        /// <param name="parameters">The cursor pagination parameters including the page size, current cursor, and pagination order.</param>
        /// <returns>A task that represents the asynchronous operation. The task result contains the <see cref="CursorPaginationResult{T, TKey}"/>, 
        /// which includes the set of items for the current page, the current cursor, and an indication if more items are available.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the query is null or if the parameters are null.</exception>
        public static async Task<CursorPaginationResult<T, TKey>> CursorPaginateAsync<T, TKey>(
            this IQueryable<T> query, Expression<Func<T, TKey>> keySelector, int pageSize, TKey currentCursor = default, PaginationOrder order = PaginationOrder.Ascending)
            where T : class
            where TKey : IComparable
        {
            Guard.NotNull(query, nameof(query));
            Guard.NotNull(keySelector, nameof(keySelector));

            var paginator = new CursorPaginator<T, TKey>(keySelector);
            var parameters = new CursorPaginationParameters<TKey> { PageSize = pageSize, CurrentCursor = currentCursor, Order = order };
            return await paginator.PaginateAsync(query, parameters);
        }
    }
}

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v7.0", FrameworkDisplayName = ".NET 7.0")]

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CorePagination")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("A lightweight library for paging data with EF Core, featuring easy implementation" +
    " and extensibility")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.2.1")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.2.1")]
[assembly: System.Reflection.AssemblyProductAttribute("CorePagination")]
[assembly: System.Reflection.AssemblyTitleAttribute("CorePagination")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.2.1")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/esmarlint/CorePagination")]

// Generated by the MSBuild WriteCodeFragment class.


// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CorePagination")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("CorePagination")]
[assembly: System.Reflection.AssemblyTitleAttribute("CorePagination")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v7.0", FrameworkDisplayName = ".NET 7.0")]

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CorePagination")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("A lightweight library for paging data with EF Core, featuring easy implementation" +
    " and extensibility")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.2.1")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.2.1")]
[assembly: System.Reflection.AssemblyProductAttribute("CorePagination")]
[assembly: System.Reflection.AssemblyTitleAttribute("CorePagination")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.2.1")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/esmarlint/CorePagination")]

// Generated by the MSBuild WriteCodeFragment class.


// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Paginators.Common
{
    /// <summary>
    /// Represents the base parameters for page-based pagination.
    /// </summary>
    public class PagePaginatorParameters
    {
        /// <summary>
        /// Gets or sets the number of items per page. Default is 10.
        /// </summary>
        public int PageSize { get; set; } = 10;
    }
}

﻿using CorePagination.Contracts;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Paginators.Common
{
    /// <summary>
    /// Represents the result of a basic pagination operation.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the pagination result.</typeparam>
    public class PaginationResult<T> : IPaginationResult<T>
    {
        public IEnumerable<T> Items { get; set; }
        public int PageSize { get; set; }
        public int Page { get; set; }
        public int? TotalItems { get; set; }
    }
}

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Paginators.Common
{
    /// <summary>
    /// Represents the parameters for page-based pagination, including page number and page size.
    /// </summary>
    public class PaginatorParameters : PagePaginatorParameters
    {
        /// <summary>
        /// Gets or sets the current page number. Default is 1.
        /// </summary>
        public int Page { get; set; } = 1;
    }
}

﻿using CorePagination.Contracts;
using CorePagination.Paginators.CursorPaginator;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Paginators.Common
{
    public class UrlPaginationResult<T> : IPaginationResult<T>
    {
        public IEnumerable<T> Items { get; set; }
        public int PageSize { get; set; }
        public string NextUrl { get; set; }
        public string PreviousUrl { get; set; }
        public string CurrentUrl { get; internal set; }
        public int Page { get; set; }
        public int? TotalItems { get; set; }
        public string FirstPageUrl { get; internal set; }
        public string? LastPageUrl { get; internal set; }
        public string? NextPageUrl { get; internal set; }
        public string? PreviousPageUrl { get; internal set; }
    }

    public class CursorUrlPaginationResult<T, TKey> : CursorPaginationResult<T, TKey>
        where T : class
        where TKey : IComparable
    {
        public string NextPageUrl { get; set; }
        public string CurrentUrl { get; set; }
    }

}

﻿using CorePagination.Common;
using CorePagination.Paginators.Common;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Paginators.CursorPaginator
{
    /// <summary>
    /// Represents the parameters for cursor-based pagination.
    /// </summary>
    /// <typeparam name="TKey">The type of the cursor property.</typeparam>
    public class CursorPaginationParameters<TKey> : PagePaginatorParameters
    {
        /// <summary>
        /// Gets or sets the current cursor value.
        /// </summary>
        public TKey CurrentCursor { get; set; }
        /// <summary>
        /// Gets or sets the pagination order (ascending or descending). Default is ascending.
        /// </summary>
        public PaginationOrder Order { get; set; } = PaginationOrder.Ascending;
    }
}

﻿using CorePagination.Paginators.Common;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Paginators.CursorPaginator
{
    /// <summary>
    /// Represents the result of a cursor-based pagination operation.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the pagination result.</typeparam>
    /// <typeparam name="TKey">The type of the cursor property.</typeparam>
    public class CursorPaginationResult<T, TKey> : PaginationResult<T>
    {
        /// <summary>
        /// Gets or sets the current cursor value.
        /// </summary>
        public TKey CurrentCursor { get; set; }
        /// <summary>
        /// Gets or sets the next cursor value.
        /// </summary>
        public TKey NextCursor { get; set; }
        /// <summary>
        /// Gets or sets a value indicating whether there are more items available.
        /// </summary>
        public bool HasMore { get; set; }
    }
}

﻿
using System.Linq.Expressions;
using System.Reflection;
using CorePagination.Common;
using CorePagination.Contracts;
using CorePagination.Support;
using Microsoft.EntityFrameworkCore;

namespace CorePagination.Paginators.CursorPaginator {

    /// <summary>
    /// Represents a paginator that provides cursor-based pagination functionality.
    /// </summary>
    /// <typeparam name="T">The type of the elements to be paginated.</typeparam>
    /// <typeparam name="TKey">The type of the cursor property.</typeparam>
    public class CursorPaginator<T, TKey> : IPaginationAsync<T, CursorPaginationParameters<TKey>, CursorPaginationResult<T, TKey>>
        where T : class
        where TKey : IComparable
    {
        private readonly Expression<Func<T, TKey>> _keySelector;

        /// <summary>
        /// Initializes a new instance of the CursorPaginator class with the specified key selector.
        /// </summary>
        /// <param name="keySelector">The expression used to select the cursor property.</param>
        public CursorPaginator(Expression<Func<T, TKey>> keySelector)
        {
            Guard.NotNull(keySelector, nameof(keySelector));
            _keySelector = keySelector;
        }

        /// <summary>
        /// Paginates the provided IQueryable based on the given CursorPaginationParameters.
        /// </summary>
        /// <param name="query">The IQueryable to be paginated.</param>
        /// <param name="parameters">The parameters for cursor-based pagination, including page size, current cursor, and pagination order.</param>
        /// <returns>A CursorPaginationResult containing the paginated items, current cursor, next cursor, and a flag indicating if there are more items.</returns>
        public async Task<CursorPaginationResult<T, TKey>> PaginateAsync(IQueryable<T> query, CursorPaginationParameters<TKey> parameters)
        {
            Guard.NotNull(query, nameof(query));
            Guard.NotNull(parameters, nameof(parameters));

            IQueryable<T> orderedQuery = parameters.Order == PaginationOrder.Ascending
                ? query.OrderBy(_keySelector)
                : query.OrderByDescending(_keySelector);

            if (parameters.CurrentCursor != null)
            {
                var parameter = Expression.Parameter(typeof(T), "x");
                var property = Expression.Invoke(_keySelector, parameter);
                var cursorValue = Expression.Constant(parameters.CurrentCursor, typeof(TKey));
                var comparison = parameters.Order == PaginationOrder.Ascending
                    ? Expression.GreaterThan(property, cursorValue)
                    : Expression.LessThan(property, cursorValue);
                var lambda = Expression.Lambda<Func<T, bool>>(comparison, parameter);

                orderedQuery = orderedQuery.Where(lambda);
            }

            var itemsWithPossibleNext = await orderedQuery.Take(parameters.PageSize + 1).ToListAsync();
            var hasMore = itemsWithPossibleNext.Count > parameters.PageSize;
            var items = itemsWithPossibleNext.Take(parameters.PageSize).ToList();

            TKey nextCursor = default(TKey);
            if (hasMore)
            {
                var propInfo = typeof(T).GetProperty(((_keySelector.Body as MemberExpression)?.Member as PropertyInfo)?.Name);
                var lastItem = items.LastOrDefault();
                if (lastItem != null && propInfo != null)
                {
                    nextCursor = (TKey)propInfo.GetValue(lastItem);
                }
            }

            return new CursorPaginationResult<T, TKey>
            {
                Items = items,
                PageSize = parameters.PageSize,
                CurrentCursor = parameters.CurrentCursor,
                NextCursor = nextCursor,
                HasMore = hasMore
            };
        }

        /// <summary>
        /// Paginates the provided IQueryable based on the given CursorPaginationParameters.
        /// </summary>
        /// <param name="query">The IQueryable to be paginated.</param>
        /// <param name="parameters">The parameters for cursor-based pagination, including page size, current cursor, and pagination order.</param>
        /// <returns>A CursorPaginationResult containing the paginated items, current cursor, next cursor, and a flag indicating if there are more items.</returns>
        public CursorPaginationResult<T, TKey> Paginate(IQueryable<T> query, CursorPaginationParameters<TKey> parameters)
        {
            Guard.NotNull(query, nameof(query));
            Guard.NotNull(parameters, nameof(parameters));

            IQueryable<T> orderedQuery = parameters.Order == PaginationOrder.Ascending
                ? query.OrderBy(_keySelector)
                : query.OrderByDescending(_keySelector);

            if (parameters.CurrentCursor != null)
            {
                var parameter = Expression.Parameter(typeof(T), "x");
                var property = Expression.Invoke(_keySelector, parameter);
                var cursorValue = Expression.Constant(parameters.CurrentCursor, typeof(TKey));
                var comparison = parameters.Order == PaginationOrder.Ascending
                    ? Expression.GreaterThan(property, cursorValue)
                    : Expression.LessThan(property, cursorValue);
                var lambda = Expression.Lambda<Func<T, bool>>(comparison, parameter);

                orderedQuery = orderedQuery.Where(lambda);
            }

            var itemsWithPossibleNext = orderedQuery.Take(parameters.PageSize + 1).ToList();
            var hasMore = itemsWithPossibleNext.Count > parameters.PageSize;
            var items = itemsWithPossibleNext.Take(parameters.PageSize).ToList();

            TKey nextCursor = default(TKey);
            if (hasMore)
            {
                var propInfo = typeof(T).GetProperty(((_keySelector.Body as MemberExpression)?.Member as PropertyInfo)?.Name);
                var lastItem = items.LastOrDefault();
                if (lastItem != null && propInfo != null)
                {
                    nextCursor = (TKey)propInfo.GetValue(lastItem);
                }
            }

            return new CursorPaginationResult<T, TKey>
            {
                Items = items,
                PageSize = parameters.PageSize,
                CurrentCursor = parameters.CurrentCursor,
                NextCursor = nextCursor,
                HasMore = hasMore
            };
        }
    }
}
﻿using CorePagination.Contracts;
using CorePagination.Paginators.Common;
using CorePagination.Support;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Paginators.SimplePaginator
{
    /// <summary>
    /// Represents a simple paginator that provides basic pagination functionality.
    /// </summary>
    /// <typeparam name="T">The type of the elements to be paginated.</typeparam>
    public class SimplePaginator<T> : IPaginationAsync<T, PaginatorParameters, PaginationResult<T>>
    {
        /// <summary>
        /// Paginates the provided IQueryable based on the given PaginatorParameters.
        /// </summary>
        /// <param name="query">The IQueryable to be paginated.</param>
        /// <param name="parameters">The parameters for pagination, including page number and page size.</param>
        /// <returns>A PaginationResult containing the paginated items and pagination information.</returns>
        public PaginationResult<T> Paginate(IQueryable<T> query, PaginatorParameters parameters)
        {
            Guard.NotNull(query, nameof(query));
            Guard.NotNull(parameters, nameof(parameters));

            var items = query.Skip((parameters.Page - 1) * parameters.PageSize).Take(parameters.PageSize).ToList();
            return new PaginationResult<T>
            {
                Items = items,
                PageSize = parameters.PageSize,
                Page = parameters.Page,
                TotalItems = null
            };
        }

        /// <summary>
        /// Paginates the provided IQueryable based on the given PaginatorParameters.
        /// </summary>
        /// <param name="query">The IQueryable to be paginated.</param>
        /// <param name="parameters">The parameters for pagination, including page number and page size.</param>
        /// <returns>A PaginationResult containing the paginated items and pagination information.</returns>
        public async Task<PaginationResult<T>> PaginateAsync(IQueryable<T> query, PaginatorParameters parameters)
        {
            Guard.NotNull(query, nameof(query));
            Guard.NotNull(parameters, nameof(parameters));

            var items = await query.Skip((parameters.Page - 1) * parameters.PageSize).Take(parameters.PageSize).ToListAsync();
            return new PaginationResult<T>
            {
                Items = items,
                PageSize = parameters.PageSize,
                Page = parameters.Page,
                TotalItems = null
            };
        }

        /// <summary>
        /// Paginates the provided IQueryable based on the given page number and page size.
        /// </summary>
        /// <param name="query">The IQueryable to be paginated.</param>
        /// <param name="pageNumber">The page number of the desired page.</param>
        /// <param name="pageSize">The number of items per page.</param>
        /// <returns>A PaginationResult containing the paginated items and pagination information.</returns>
        public async Task<PaginationResult<T>> PaginateAsync(IQueryable<T> query, int pageNumber, int pageSize)
        {
            var parameters = new PaginatorParameters { Page = pageNumber, PageSize = pageSize };
            return await PaginateAsync(query, parameters);
        }
    }
}

﻿using CorePagination.Paginators.Common;

namespace CorePagination.Paginators.SizeAwarePaginator
{
    /// <summary>
    /// Represents the result of a pagination operation that includes total item and page counts.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the pagination result.</typeparam>
    public class SizeAwarePaginationResult<T> : PaginationResult<T>
    {
        /// <summary>
        /// Gets or sets the total number of pages.
        /// </summary>
        public int TotalPages { get; set; }
    }
}
﻿using CorePagination.Contracts;
using CorePagination.Paginators.Common;
using CorePagination.Support;
using Microsoft.EntityFrameworkCore;

namespace CorePagination.Paginators.SizeAwarePaginator
{

    /// <summary>
    /// Represents a paginator that provides pagination functionality with total item and page count.
    /// </summary>
    /// <typeparam name="T">The type of the elements to be paginated.</typeparam>
    public class SizeAwarePaginator<T> : IPaginationAsync<T, PaginatorParameters, SizeAwarePaginationResult<T>>
    {
        /// <summary>
        /// Paginates the provided IQueryable based on the given PaginatorParameters and calculates total item and page count.
        /// </summary>
        /// <param name="query">The IQueryable to be paginated.</param>
        /// <param name="parameters">The parameters for pagination, including page number and page size.</param>
        /// <returns>A SizeAwarePaginationResult containing the paginated items, total item count, total page count, and other pagination information.</returns>
        public SizeAwarePaginationResult<T> Paginate(IQueryable<T> query, PaginatorParameters parameters)
        {
            Guard.NotNull(query, nameof(query));
            Guard.NotNull(parameters, nameof(parameters));

            var totalItems = query.Count();
            var totalPages = (int)Math.Ceiling(totalItems / (double)parameters.PageSize);
            var items = query.Skip((parameters.Page - 1) * parameters.PageSize).Take(parameters.PageSize).ToList();

            return new SizeAwarePaginationResult<T>
            {
                Items = items,
                PageSize = parameters.PageSize,
                Page = parameters.Page,
                TotalItems = totalItems,
                TotalPages = totalPages
            };
        }

        /// <summary>
        /// Paginates the provided IQueryable based on the given PaginatorParameters and calculates total item and page count.
        /// </summary>
        /// <param name="query">The IQueryable to be paginated.</param>
        /// <param name="parameters">The parameters for pagination, including page number and page size.</param>
        /// <returns>A SizeAwarePaginationResult containing the paginated items, total item count, total page count, and other pagination information.</returns>
        public async Task<SizeAwarePaginationResult<T>> PaginateAsync(IQueryable<T> query, PaginatorParameters parameters)
        {
            Guard.NotNull(query, nameof(query));
            Guard.NotNull(parameters, nameof(parameters));

            var items = await query.Skip((parameters.Page - 1) * parameters.PageSize).Take(parameters.PageSize).ToListAsync();
            var totalItems = await query.CountAsync();
            var totalPages = (int)Math.Ceiling(totalItems / (double)parameters.PageSize);

            return new SizeAwarePaginationResult<T>
            {
                Items = items,
                PageSize = parameters.PageSize,
                Page = parameters.Page,
                TotalItems = totalItems,
                TotalPages = totalPages
            };
        }

        /// <summary>
        /// Paginates the provided IQueryable based on the given page number and page size, and calculates total item and page count.
        /// </summary>
        /// <param name="query">The IQueryable to be paginated.</param>
        /// <param name="pageNumber">The page number of the desired page.</param>
        /// <param name="pageSize">The number of items per page.</param>
        /// <returns>A SizeAwarePaginationResult containing the paginated items, total item count, total page count, and other pagination information.</returns>
        public async Task<SizeAwarePaginationResult<T>> PaginateAsync(IQueryable<T> query, int pageNumber, int pageSize)
        {
            var parameters = new PaginatorParameters { Page = pageNumber, PageSize = pageSize };
            return await PaginateAsync(query, parameters);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Support
{
    internal static class Guard
    {
        public static void NotNull(object input, string parameterName = null)
        {
            if (input == null)
            {
                throw new ArgumentNullException(parameterName ?? "Value", "Value cannot be null.");
            }
        }

    }
}

﻿using CorePagination.Contracts;

namespace CorePagination.Tranformation.Contracts
{
    /// <summary>
    /// Defines the contract for transforming a pagination result into a different format.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the original pagination result.</typeparam>
    /// <typeparam name="TResult">The type of the transformed pagination result.</typeparam>
    public interface IPaginationTranformer<T, TResult>
        where T : class
        where TResult : class
    {
        /// <summary>
        /// Transforms the specified pagination result into a different format.
        /// </summary>
        /// <param name="paginationResult">The pagination result to be transformed.</param>
        /// <returns>The transformed pagination result.</returns>
        TResult Transform(IPaginationResult<T> paginationResult);
    }

}

﻿using CorePagination.Contracts;
using CorePagination.Paginators.Common;

namespace CorePagination.Tranformation.Contracts
{
    public abstract class UrlResultTransformerBase<T, TResult> : IPaginationTranformer<T, TResult> where T : class where TResult : class, new()
    {
        protected readonly string _baseUrl;
        protected readonly Dictionary<string, string> _parametersToInclude = new Dictionary<string, string>();
        protected readonly Dictionary<string, string> _parameterRenames = new Dictionary<string, string>();

        protected UrlResultTransformerBase(string baseUrl = "")
        {
            _baseUrl = baseUrl;
        }

        public UrlResultTransformerBase<T, TResult> IncludePage()
        {
            _parametersToInclude["page"] = "page";
            return this;
        }

        public UrlResultTransformerBase<T, TResult> IncludePageSize()
        {
            _parametersToInclude["pageSize"] = "pageSize";
            return this;
        }

        public UrlResultTransformerBase<T, TResult> RenameParameter(string originalName, string newName)
        {
            if (_parametersToInclude.ContainsKey(originalName))
            {
                _parameterRenames[originalName] = newName;
            }

            return this;
        }

        public UrlResultTransformerBase<T, TResult> AddParameter(string name, string value)
        {
            _parametersToInclude[name] = value;
            return this;
        }

        public abstract TResult Transform(IPaginationResult<T> paginationResult);
    }


}

﻿using CorePagination.Contracts;
using CorePagination.Paginators.Common;
using CorePagination.Tranformation.Transformers;

namespace CorePagination.Tranformation.Extensions
{
    /// <summary>
    /// Applies a URL transformation using the appropriate transformer based on the type of pagination result.
    /// </summary>
    /// <param name="paginationResult">The pagination result to transform.</param>
    /// <param name="baseUrl">The base URL to use for generating navigation links.</param>
    /// <returns>The transformed pagination result with enhanced navigational URLs.</returns>
    public static class PaginationExtensions
    {
        public static UrlPaginationResult<T> WithSimpleUrl<T>(this IPaginationResult<T> paginationResult, string baseUrl)
                 where T : class
        {
            var transformer = new SimpleUrlResultTransformer<T>(baseUrl);
            return transformer.Transform(paginationResult);
        }

        /// <summary>
        /// Applies a URL transformation to the pagination result using the SizeAwareUrlResultTransformer.
        /// </summary>
        /// <param name="paginationResult">The pagination result to transform.</param>
        /// <param name="baseUrl">The base URL to be used for generating navigational links.</param>
        /// <returns>A UrlPaginationResult with the transformed URLs included.</returns>
        /// <typeparam name="T">The type of the elements in the pagination result.</typeparam>
        public static UrlPaginationResult<T> WithUrl<T>(this IPaginationResult<T> paginationResult, string baseUrl)
            where T : class
        {
            var transformer = new SizeAwareUrlResultTransformer<T>(baseUrl);
            return transformer.Transform(paginationResult);
        }

        /// <summary>
        /// Applies a URL transformation to the pagination result using the CursorUrlResultTransformer.
        /// </summary>
        /// <param name="paginationResult">The pagination result to transform.</param>
        /// <param name="baseUrl">The base URL to be used for generating navigational links.</param>
        /// <returns>A CursorUrlPaginationResult with the transformed URLs included.</returns>
        /// <typeparam name="T">The type of the elements in the pagination result.</typeparam>
        /// <typeparam name="TKey">The type of the key used for cursor pagination, which must be comparable.</typeparam>
        public static CursorUrlPaginationResult<T, TKey> WithUrl<T, TKey>(
            this IPaginationResult<T> paginationResult, string baseUrl)
            where T : class
            where TKey : IComparable
        {
            var transformer = new CursorUrlResultTranformer<T, TKey>(baseUrl);
            return (CursorUrlPaginationResult<T, TKey>)transformer.Transform(paginationResult);
        }
    }
}

﻿using CorePagination.Contracts;
using CorePagination.Paginators.SimplePaginator;
using CorePagination.Support;

namespace CorePagination.Tranformation.Extensions
{
    public static class PaginationTransformationExtensions
    {
        /// <summary>
        /// Transforms the specified pagination result using the provided transformation function.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the original pagination result.</typeparam>
        /// <typeparam name="TResult">The type of the transformed pagination result.</typeparam>
        /// <param name="paginationResult">The original pagination result to transform.</param>
        /// <param name="transformation">A function that transforms the pagination result into the desired format.</param>
        /// <returns>The transformed pagination result.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the paginationResult or the transformation function is null.</exception>
        public static TResult Transform<T, TResult>(
            this IPaginationResult<T> paginationResult,
            Func<IPaginationResult<T>, TResult> transformation) where TResult : class
        {
            Guard.NotNull(paginationResult, nameof(paginationResult));

            return transformation(paginationResult);
        }

        /// <summary>
        /// Transforms the specified pagination result using the provided transformation function, including transformation of the items within the result.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the original pagination result.</typeparam>
        /// <typeparam name="TResult">The type of the transformed pagination result where TResult must implement IPaginationResult&lt;T&gt;.</typeparam>
        /// <param name="paginationResult">The original pagination result to transform.</param>
        /// <param name="transformation">A function that transforms both the pagination result and its items.</param>
        /// <returns>The transformed pagination result with transformed items.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the paginationResult or the transformation function is null.</exception>
        public static TResult TransformWithItems<T, TResult>(
            this IPaginationResult<T> paginationResult,
            Func<IPaginationResult<T>, TResult> transformation) where TResult : IPaginationResult<T>, new()
        {
            Guard.NotNull(paginationResult, nameof(paginationResult));

            var result = transformation(paginationResult);
            if (result is IPaginationResult<T> paginationResultWithItems)
            {
                paginationResultWithItems.Items = paginationResult.Items;
            }
            return result;
        }
    }
}

﻿using CorePagination.Contracts;
using CorePagination.Paginators.Common;
using CorePagination.Paginators.CursorPaginator;
using CorePagination.Support;
using CorePagination.Tranformation.Contracts;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CorePagination.Tranformation.Transformers
{
    /// <summary>
    /// Transforms a cursor-based pagination result into a <see cref="CursorUrlPaginationResult{T, TKey}"/>, 
    /// enhancing it with navigational URLs for cursor-based pagination.
    /// </summary>
    /// <remarks>
    /// This transformer is particularly useful in APIs where cursor-based navigation is implemented, 
    /// allowing clients to navigate through the dataset using cursors instead of page numbers. The transformed
    /// result includes URLs that clients can use to request the next set of results or go back to the previous set.
    /// </remarks>
    /// <typeparam name="T">The type of the elements in the pagination result.</typeparam>
    /// <typeparam name="TKey">The type of the cursor.</typeparam>
    public class CursorUrlResultTranformer<T, TKey> : UrlResultTransformerBase<T, CursorUrlPaginationResult<T, TKey>>
        where T : class
        where TKey : IComparable
    {
        private readonly string _baseUrl;
        private bool _includeCurrentCursor;
        private bool _includeNextCursor;
        private bool _includeDirection;

        /// <summary>
        /// Initializes a new instance of the <see cref="CursorUrlResultTransformer{T, TKey}"/> class using the specified base URL for link generation.
        /// </summary>
        /// <param name="baseUrl">The base URL to be used for generating navigational links. This URL should not include cursor query parameters.</param>
        /// <exception cref="ArgumentNullException">Thrown if the baseUrl is null or empty.</exception>
        public CursorUrlResultTranformer(string baseUrl)
        {
            Guard.NotNull(baseUrl, nameof(baseUrl));
            _baseUrl = baseUrl;
        }

        /// <summary>
        /// Transforms the given pagination result into a <see cref="CursorUrlPaginationResult{T, TKey}"/>
        /// by appending navigation links appropriate for cursor-based pagination.
        /// </summary>
        /// <param name="paginationResult">The pagination result to transform.</param>
        /// <returns>A <see cref="CursorUrlPaginationResult{T, TKey}"/> that includes cursor-based navigational URLs.</returns>
        /// <exception cref="ArgumentNullException">Thrown when the pagination result is null.</exception>
        /// <exception cref="ArgumentException">Thrown when the pagination result is not compatible with cursor-based pagination.</exception>
        public override CursorUrlPaginationResult<T, TKey> Transform(IPaginationResult<T> paginationResult)
        {
            Guard.NotNull(paginationResult, nameof(paginationResult));

            var cursorPaginationResult = paginationResult as CursorUrlPaginationResult<T, TKey>;
            if (cursorPaginationResult == null)
            {
                throw new ArgumentException("The pagination result is not a cursor pagination result.", nameof(paginationResult));
            }

            var queryParams = new List<string>
            {
                $"pageSize={cursorPaginationResult.PageSize}"
            };

            if (_includeCurrentCursor && cursorPaginationResult.CurrentCursor != null)
            {
                queryParams.Add($"currentCursor={cursorPaginationResult.CurrentCursor}");
            }

            if (_includeNextCursor && cursorPaginationResult.NextCursor != null)
            {
                queryParams.Add($"nextCursor={cursorPaginationResult.NextCursor}");
            }

            if (_includeDirection)
            {
                var direction = cursorPaginationResult.CurrentCursor ;
                queryParams.Add($"direction={direction}");
            }

            var queryString = string.Join("&", queryParams);
            var baseUrlWithParams = $"{_baseUrl}?{queryString}";

            return new CursorUrlPaginationResult<T, TKey>
            {
                Items = cursorPaginationResult.Items,
                PageSize = cursorPaginationResult.PageSize,
                CurrentCursor = cursorPaginationResult.CurrentCursor,
                NextCursor = cursorPaginationResult.NextCursor,
                CurrentUrl = baseUrlWithParams
            };
        }

        #region Fluent API
        /// <summary>
        /// Configures the transformer to include the current cursor value in the pagination results.
        /// </summary>
        /// <returns>The instance of <see cref="CursorUrlResultTransformer{T, TKey}"/> for further configuration.</returns>
        public CursorUrlResultTranformer<T, TKey> IncludeCurrentCursor()
        {
            _includeCurrentCursor = true;
            return this;
        }

        /// <summary>
        /// Configures the transformer to include the next cursor value, facilitating forward navigation in the pagination results.
        /// </summary>
        /// <returns>The instance of <see cref="CursorUrlResultTransformer{T, TKey}"/> for further configuration.</returns>
        public CursorUrlResultTranformer<T, TKey> IncludeNextCursor()
        {
            _includeNextCursor = true;
            return this;
        }

        #endregion
    }

}

﻿using CorePagination.Contracts;
using CorePagination.Paginators.Common;
using CorePagination.Support;
using CorePagination.Tranformation.Contracts;

namespace CorePagination.Tranformation.Transformers
{
    /// <summary>
    /// Transforms a pagination result into a URL-enhanced pagination result, adding navigational links for easier user interface interaction.
    /// </summary>
    /// <remarks>
    /// Ideal for web APIs where consumers need to navigate through paginated results. It appends URL links for navigating between pages.
    /// </remarks>
    /// <typeparam name="T">The type of the elements in the pagination result.</typeparam>
    public class SimpleUrlResultTransformer<T> : UrlResultTransformerBase<T, UrlPaginationResult<T>> where T : class
    {
        private readonly string _baseUrl;
        private readonly Dictionary<string, string> _parametersToInclude = new Dictionary<string, string>();
        private readonly Dictionary<string, string> _parameterRenames = new Dictionary<string, string>();

        /// <summary>
        /// Initializes a new instance of the <see cref="SimpleUrlResultTransformer{T}"/> class using the specified base URL for link generation.
        /// </summary>
        /// <param name="baseUrl">The base URL used for generating navigational links. This URL should not include any pagination query parameters.</param>
        /// <exception cref="ArgumentNullException">Thrown if the baseUrl is null or empty.</exception>
        public SimpleUrlResultTransformer(string baseUrl = "")
        {
            _baseUrl = baseUrl;
        }

        /// <summary>
        /// Transforms the given pagination result into a <see cref="UrlPaginationResult{T}"/>, 
        /// adding URL navigation links based on the specified base URL.
        /// </summary>
        /// <param name="paginationResult">The pagination result to be transformed.</param>
        /// <returns>A <see cref="UrlPaginationResult{T}"/> that includes navigational URLs for the paginated data.</returns>
        /// <exception cref="ArgumentNullException">Thrown if the paginationResult is null.</exception>
        public override UrlPaginationResult<T> Transform(IPaginationResult<T> paginationResult)
        {
            Guard.NotNull(paginationResult, nameof(paginationResult));

            var currentPage = paginationResult.Page;
            var pageSize = paginationResult.PageSize;
            var hasNextPage = paginationResult.Items.Count() == pageSize;
            var hasPrevPage = currentPage > 1;

            var baseQueryString = _parametersToInclude.Select(kv =>
            {
                string value = kv.Key switch
                {
                    "page" => currentPage.ToString(),
                    "pageSize" => pageSize.ToString(),
                    _ => kv.Value
                };
                return $"{_parameterRenames.GetValueOrDefault(kv.Key, kv.Key)}={value}";
            }).ToList();

            string BuildUrl(int page) => $"{_baseUrl}?{string.Join("&", baseQueryString)}".Replace($"page={currentPage}", $"page={page}");

            return new UrlPaginationResult<T>
            {
                Items = paginationResult.Items,
                PageSize = pageSize,
                Page = currentPage,
                TotalItems = paginationResult.TotalItems,
                FirstPageUrl = BuildUrl(1),
                PreviousUrl = hasPrevPage ? BuildUrl(currentPage - 1) : null,
                CurrentUrl = BuildUrl(currentPage),
                NextUrl = hasNextPage ? BuildUrl(currentPage + 1) : null
            };
        }

    }

}

﻿using CorePagination.Contracts;
using CorePagination.Paginators.Common;
using CorePagination.Support;
using CorePagination.Tranformation.Contracts;

namespace CorePagination.Tranformation.Transformers
{
    /// <summary>
    /// Initializes a new instance of the <see cref="SizeAwareUrlResultTransformer{T}"/> class.
    /// Sets up the transformer with the base URL for generating navigation links.
    /// </summary>
    /// <param name="baseUrl">The base URL used for appending navigation links to the pagination results.</param>
    /// <exception cref="ArgumentNullException">Thrown when the baseUrl is null or empty.</exception>

    public class SizeAwareUrlResultTransformer<T> : UrlResultTransformerBase<T, UrlPaginationResult<T>> where T : class
    {
        private readonly string _baseUrl;
        private bool _includeTotalItems;
        private bool _includeTotalPages;

        /// <summary>
        /// Initializes a new instance of the <see cref="SizeAwareUrlResultTransformer{T}"/> class.
        /// This constructor sets up the transformer with the base URL to be used for generating navigation links.
        /// </summary>
        /// <param name="baseUrl">The base URL to be used for appending navigation links to the pagination results.</param>
        /// <exception cref="ArgumentNullException">Thrown when the baseUrl is null or empty.</exception>
        public SizeAwareUrlResultTransformer(string baseUrl)
        {
            Guard.NotNull(baseUrl, nameof(baseUrl));
            _baseUrl = baseUrl;
        }

        /// <summary>
        /// Transforms the specified pagination result into a <see cref="UrlPaginationResult{T}"/>
        /// by appending URL navigation links that include pagination details like page number and size.
        /// When configured, it can also include total items and total pages information.
        /// </summary>
        /// <param name="paginationResult">The pagination result to transform.</param>
        /// <returns>A <see cref="UrlPaginationResult{T}"/> enhanced with navigational URLs.</returns>
        /// <exception cref="ArgumentNullException">Thrown when the pagination result is null.</exception>
        public override UrlPaginationResult<T> Transform(IPaginationResult<T> paginationResult)
        {
            Guard.NotNull(paginationResult, nameof(paginationResult));

            var currentPage = paginationResult.Page;
            var totalItems = paginationResult.TotalItems ?? 0;
            var pageSize = paginationResult.PageSize;
            var totalPages = (int)Math.Ceiling((double)totalItems / pageSize);

            var queryParams = new List<string>
            {
                $"page={currentPage}",
                $"pageSize={pageSize}"
            };

            if (_includeTotalItems)
            {
                queryParams.Add($"totalItems={totalItems}");
            }

            if (_includeTotalPages)
            {
                queryParams.Add($"totalPages={totalPages}");
            }

            var queryString = string.Join("&", queryParams);
            var baseUrlWithParams = $"{_baseUrl}?{queryString}";

            return new UrlPaginationResult<T>
            {
                Items = paginationResult.Items,
                PageSize = pageSize,
                Page = currentPage,
                TotalItems = totalItems,
                FirstPageUrl = $"{baseUrlWithParams}&page=1",
                LastPageUrl = $"{baseUrlWithParams}&page={totalPages}",
                NextPageUrl = currentPage < totalPages ? $"{baseUrlWithParams}&page={currentPage + 1}" : null,
                PreviousPageUrl = currentPage > 1 ? $"{baseUrlWithParams}&page={currentPage - 1}" : null,
                CurrentUrl = baseUrlWithParams,
            };
        }

        #region Fluent API
        /// <summary>
        /// Configures the transformer to include the total count of items in the pagination results.
        /// </summary>
        /// <returns>The instance of <see cref="SizeAwareUrlResultTransformer{T}"/> for further configuration.</returns>
        public SizeAwareUrlResultTransformer<T> IncludeTotalItems()
        {
            _includeTotalItems = true;
            return this;
        }

        /// <summary>
        /// Configures the transformer to include the total number of pages in the pagination results.
        /// </summary>
        /// <returns>The instance of <see cref="SizeAwareUrlResultTransformer{T}"/> for further configuration.</returns>
        public SizeAwareUrlResultTransformer<T> IncludeTotalPages()
        {
            _includeTotalPages = true;
            return this;
        }
        #endregion

    }

}

